<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Monads</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><hr>



<h2 id="this-document-is-incomplete-and-a-work-in-progress">THIS DOCUMENT IS INCOMPLETE AND A WORK IN PROGRESS!</h2>



<h1 id="monads">Monads</h1>

<p>Before writing an article on monads I would like to say that the subject seems a bit less controversial these days. Because of this I would like to do a more <em>theoretical</em> version of the monad than most people are doing. This article is more like a recipe for creating monads than a mathematical definition. We are however going to circle back to <em>monoids</em> and <em>Category Theory</em> at the end of the article.</p>

<p>I am going to provide examples in C#, F# and JavaScript. I am going to ignore Haskell and Lispy languages like Clojure and of course List because I don’t think that adding these languages provides any more relevant information on monads. I do think that learning Haskell is the only way to learn functional programming. I also believe that List is a fabulous language. I really think that learning a programming language a year is a great way to become a master programmer; but, learning monads is quintessential to mastering business applications.</p>

<p>This tutorial will start with simple objects representing monads, we will add functions to these objects so that we get the coveted associativity and the identity function without starting from <em>monoids</em>. At the end of the article we will look at <em>monoids</em> and look at how we can come back to <em>monads</em> from them. </p>

<blockquote>
  <p><strong>Disclaimer:</strong> I’m a JavaScript programmer. This might not mean anything to you, but it means a lot to me. I circumvent all pretense of a type system. I think type systems often serve an academic purpose. Our applications are usually <em>not so difficult</em> as to warrant the use of a compiler or a strong type system. Anyone who tries to sell the profession of writing <em>Line of Business Applications</em> as being difficult should look at Image Processing, Data Mining, Data Transformations and the necessary performance optimizations needed there.  <br>
  We, as a profession, tend to be lazy in general. I’ve met a lot of C# programmers who simply do not care about learning other programming languages or <em>monads</em>. I’ve also met Functional Program enthusiasts who do not want to learn the OOP paradigm.  I think that monads are worth your while to learn just as I think OOP is worth every FP’s effort.</p>
</blockquote>

<p>What do you need to know to read this article? </p>

<ul>
<li>Generics</li>
</ul>



<h2 id="constructors">Constructors</h2>

<p>What is a constructor? A constructor is a function which returns an object. In C# a constructor would look something like:</p>



<pre class="prettyprint"><code class=" hljs cs">class Person {
    <span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>() {
    }
}</code></pre>

<p>When we look at this notation I always get a bit “itchy”. The fact that there is something which looks like a function but returns nothing scares me. In ES6 this looks a bit different:</p>



<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> {</span>
    constructor() {
    }
}</code></pre>

<p>For some reason, this JavaScript code,  seems less strange to me; because you write the actual word <code>constructor</code> instead of using the name of the class, you get the feeling that this function is special. Apart from this fact, JavaScript does not specify return types and as such there is nothing different about this function. </p>



<h2 id="lift">Lift</h2>

<p>We will define an operation called <code>lift</code> as an operation looks a lot like a constructor, the <code>lift</code> function is closely linked to the <em>identity element</em> of a collection. There is an entire philosophical and mathematical reason for calling this function the <code>lift</code> function but we are going to ignore that. I think that the terminology is one of the most important parts of learning these difficult concepts and learning terminology should be done in three steps:</p>

<ol>
<li>Learn the term</li>
<li>Use the term correctly</li>
<li>Learn the etymology of the term</li>
</ol>

<p>We are going to try and follow this path. Blindly learn the new thing. Use the new thing is examples and exercises. At the end of the article we will try and get to the bottom of the origin of the term and figure out what it means. </p>

<p>Let’s create a type which will serve as the base for our <em>monadic type</em>:</p>

<pre class="prettyprint"><code class=" hljs cs">class Monad&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> T Value;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Monad</span>(T t) {
        <span class="hljs-keyword">this</span>.Value = t;
    }
}</code></pre>

<p>These are the beginnings of a <em>Monadic Type</em>, this constructor is a way to create a <em>Monad</em>. If we were to be a bit more formal we’d define a function called <code>lift</code> instead of the constructor like so:</p>

<p><script type="math/tex; mode=display" id="MathJax-Element-4">
lift \; :: \; a \rightarrow M a
</script></p>

<p>In C# this unit function would look a lot like:</p>

<pre class="prettyprint"><code class=" hljs cs">class Monad&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> T Value;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Monad</span>(T t) {
        <span class="hljs-keyword">this</span>.Value = t;
    }

    <span class="hljs-comment">// lift :: T -&gt; Monad&lt;T&gt;</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Monad&lt;T&gt; <span class="hljs-title">Lift</span>(T t) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Monad&lt;T&gt;(t);
    }
}</code></pre>

<p>This <code>Lift</code> function takes a value in type <code>T</code> and returns a value in type <code>Monad&lt;T&gt;</code>. If your language has referential transparency we could even say that:</p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> Monad&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">12</span>) == Monad&lt;<span class="hljs-keyword">int</span>&gt;.Lift(<span class="hljs-number">12</span>)) {
    Console.WriteLine(<span class="hljs-string">"They are the same!!"</span>);
}
<span class="hljs-keyword">else</span> {
    Console.WriteLine(<span class="hljs-string">"Oh no, C# only cares about pointers!"</span>);
}</code></pre>

<p>This result here is my first beef with languages like C#. Comparing things is the most basic of operation in a business application and comparing things by reference is not a great way to it. We should compare the values inside the objects instead of the references, the pointers. </p>

<p>Let’s look at how this would look in F#; first, here’s the code for our monad:</p>

<pre class="prettyprint"><code class=" hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Monad</span>&lt;'<span class="hljs-title">a</span>&gt; =</span> Value <span class="hljs-keyword">of</span> <span class="hljs-attribute">'a</span></code></pre>

<p>The unit function would look something like:</p>



<pre class="prettyprint"><code class=" hljs livecodeserver">let lift <span class="hljs-operator">a</span> = Value <span class="hljs-operator">a</span></code></pre>

<p>We can use this code by invoking the<code>unit</code> function and matching the result, printing something with the Value:</p>

<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-keyword">let</span> m12 <span class="hljs-subst">=</span> lift <span class="hljs-number">12</span>
<span class="hljs-keyword">match</span> m12 <span class="hljs-keyword">with</span>
<span class="hljs-subst">|</span> Value n <span class="hljs-subst">-&gt; </span>printf <span class="hljs-string">"Value is: %d"</span> n</code></pre>

<p>The great thing about languages like F# is that we can do:</p>

<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-keyword">match</span> Value <span class="hljs-number">12</span> <span class="hljs-subst">=</span> lift <span class="hljs-number">12</span> <span class="hljs-keyword">with</span>
<span class="hljs-subst">|</span> <span class="hljs-literal">True</span> <span class="hljs-subst">-&gt; </span>printf <span class="hljs-string">"WOOT!"</span>
<span class="hljs-subst">|</span> <span class="hljs-literal">False</span> <span class="hljs-subst">-&gt; </span>printf <span class="hljs-string">"No woot ;("</span></code></pre>

<p>Not only is the result <code>WOOT!</code>, but I can pattern match on the result, this means that there are no <em>cases</em> which I’ve missed. This is checked and enforced by the compiler.</p>

<p>Let’s look at the same example but this time let’s use JavaScript. I am not  going to write ES6 classes because I personally don’t like them. I really don’t like this syntax which everyone seems to be so <em>comfortable</em> with. Apart from this, a constructor in JavaScript is not a constructor like we know in for example C# or Java. This will most certainly be a subject of another article.</p>

<p>In JavaScript a <em>class</em> is simply a <em>function</em> we write it with a capital letter because sir Crockford taught us that that’s the way to do it. To be honest, style conventions are quite powerful and should not be ignored. </p>

<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Monad</span><span class="hljs-params">(value)</span> {</span>
    <span class="hljs-keyword">this</span>.Value = value;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lift</span><span class="hljs-params">(value)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Monad(value);
}</code></pre>

<p>The <code>lift</code> function is quite simple as well. Because we don’t have a compiler and an enforced type system we can just <em>write what we want</em>. </p>

<p>Just like with C# <code>lift(12) === new Monad(12)</code> will also result in <code>false</code>.  This is because JavaScript and C# both check equality by comparing the references, the pointers. These are of course different because they point to different objects. In C# we could override the operator <code>==</code> and <code>!=</code> to make sure we compare the <code>Value</code> property:</p>

<pre class="prettyprint"><code class=" hljs cs">class Monad&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> T Value;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Monad</span>(T t) {
        <span class="hljs-keyword">this</span>.Value = t;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Monad&lt;T&gt; <span class="hljs-title">Lift</span>(T t) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Monad&lt;T&gt;(t);
    }

    <span class="hljs-comment">// Overload the operators...</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> == (Monad&lt;T&gt; a, Monad&lt;T&gt; b) {
        <span class="hljs-keyword">return</span> EqualityComparer&lt;T&gt;.Default.Equals(a.Value, b.Value);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> != (Monad&lt;T&gt; a, Monad&lt;T&gt; b) {
        <span class="hljs-keyword">return</span> !EqualityComparer&lt;T&gt;.Default.Equals(a.Value, b.Value);
    }
}</code></pre>

<p>But as you can imagine this will become unwieldy very fast. Here we only have to check a single value. Imagine having multiple properties….oh the horror! I think it is safe to say that F# is the clear winner when it comes to writing our monadic type and our unit function in a clear and succinct way. </p>

<p>This is my second beef with languages like C#, everything takes so much code to write. It doesn’t matter if you go fully untyped like JavaScript or super typed, at least having Algebraic Data Types, like F# or Haskell, to get the same functionality but with less code. Less code is not a good thing in and of itself. Readability is very important but I’d like to argue here that what we’ve written is standard F# and as such should be readable by everyone.</p>

<blockquote>
  <p>The FP community tends to write applications using a lot of <code>x</code> and <code>y</code> for their parameters. I do the same some times. It is important to realize that just as with languages like C#, naming your parameters and functions is every important! Let’s leave the <code>x</code> and <code>y</code> alone and come up with better names.</p>
</blockquote>

<p>Up to this point we’ve only seen ways to create an object and pass some data into the constructor.  This is neither new nor exiting as far as programming goes. What matters is what this can do. The next chapter will give a small example of using this technique to create a robust system where we can work with data in very solid way.</p>

<h2 id="maybe">Maybe?</h2>

<p>We’ve all had to deal with null reference exceptions in the passed. Maybe we’ve even had applications deployed to production which crashed on a null reference exception. This is really painful because it is a clear programming error. If we had programmed more defensively and checked <strong><em>every</em></strong> object for null this error would not have occurred. </p>

<p>There must be a better way than to litter your code with null checks? There is, if you step into the land of monads you will encounter a pearl, the <em>maybe monad</em>. Look at the next piece of code. I’ve done a few things, the first thing is that I’ve added an empty constructor to the <code>Monad</code> class. The second thing is that I’ve created three new classes: <code>Maybe</code>, <code>Nothing</code> and <code>Just</code>.</p>

<p>The idea behind these classes is that we never return a data object from functions anymore but we always return <code>Maybe&lt;T&gt;</code>. If we do this we can never encounter a null reference exception in our code again!  </p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Monad&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> T Value;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Monad</span>(T t) {
        <span class="hljs-keyword">this</span>.Value = t;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-title">Monad</span>() {}

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> == (Monad&lt;T&gt; a, Monad&lt;T&gt; b) {
        <span class="hljs-keyword">return</span> EqualityComparer&lt;T&gt;.Default.Equals(a.Value, b.Value);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> != (Monad&lt;T&gt; a, Monad&lt;T&gt; b) {
        <span class="hljs-keyword">return</span> !EqualityComparer&lt;T&gt;.Default.Equals(a.Value, b.Value);
    }
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Maybe&lt;T&gt; : Monad&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-title">Maybe</span>(T t) : <span class="hljs-title">base</span>(t) {}
    <span class="hljs-keyword">public</span> <span class="hljs-title">Maybe</span>() {}
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Nothing&lt;T&gt; : Maybe&lt;T&gt; {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Just&lt;T&gt; : Maybe&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-title">Just</span>(T t) : <span class="hljs-title">base</span>(t) {}
}</code></pre>

<p>How would we use this code? Well imagine querying a database for a user by <code>Id</code>. You don’t know if the user exists or not. (<em>side note</em>: let’s ignore errors for now. The next couple of examples will focus on errors.) When you get your result you want to know for certain if what you got was a user or not. Somehow you want the compiler to catch references to nothing. Here, the <code>Maybe&lt;User&gt;</code> class can help us out. Because we’ve sub-classed <code>Maybe</code> we can <a href="https://en.wikipedia.org/wiki/Polymorphism_%28computer_science%29">upcast</a> or type-check our result and safely continue with the data once we’ve gotten the data.</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> User {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">string</span> Username;
    <span class="hljs-keyword">public</span> <span class="hljs-title">User</span>(<span class="hljs-keyword">string</span> username) {
        <span class="hljs-keyword">this</span>.Username = username;
    }

    <span class="hljs-comment">// Simulate querying the user from the database.</span>
    <span class="hljs-comment">// return Just&lt;User&gt; on odd ids</span>
    <span class="hljs-comment">// return Nothing&lt;User&gt; on even ids</span>
    <span class="hljs-keyword">static</span> Maybe&lt;User&gt; GetUserById(<span class="hljs-keyword">int</span> id) {
        <span class="hljs-keyword">if</span> (id % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> (Maybe&lt;User&gt;)<span class="hljs-keyword">new</span> Just&lt;User&gt;(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Carlos"</span>));
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> (Maybe&lt;User&gt;)<span class="hljs-keyword">new</span> Nothing&lt;User&gt;();
        }
    }
}</code></pre>

<p>We can use this code with something as simple as:</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">var</span> user = User.GetUserById(<span class="hljs-number">2</span>);
<span class="hljs-keyword">if</span> (user <span class="hljs-keyword">is</span> Nothing&lt;User&gt;) {
    Console.WriteLine(<span class="hljs-string">"We got nothing!"</span>);
}
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (user <span class="hljs-keyword">is</span> Just&lt;User&gt;) {
    Console.WriteLine(<span class="hljs-string">"We got you...."</span> + ((Just&lt;User&gt;)user).Value.Username);
}</code></pre>

<p>In this previous example you have seen polymorphism at it’s best. This is clear cut example of polymorphism and how it can help you build better software but how would we write this in F#? </p>



<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-keyword">type</span> User <span class="hljs-subst">=</span> { Username: <span class="hljs-built_in">string</span> }

<span class="hljs-keyword">type</span> Maybe<span class="hljs-subst">&lt;</span><span class="hljs-string">'a&gt; =
| Just of '</span>a
<span class="hljs-subst">|</span> Nothing

<span class="hljs-keyword">let</span> getUserById id <span class="hljs-subst">=</span>
    <span class="hljs-keyword">match</span> id <span class="hljs-subst">%</span> <span class="hljs-number">2</span> <span class="hljs-keyword">with</span>
    <span class="hljs-subst">|</span> <span class="hljs-number">0</span> <span class="hljs-subst">-&gt; </span>Just { Username <span class="hljs-subst">=</span> <span class="hljs-string">"Carlos"</span> }
    <span class="hljs-subst">|</span> _ <span class="hljs-subst">-&gt; </span>Nothing

<span class="hljs-keyword">let</span> user <span class="hljs-subst">=</span> getUserById <span class="hljs-number">2</span>

<span class="hljs-keyword">match</span> user <span class="hljs-keyword">with</span>
<span class="hljs-subst">|</span> Just u <span class="hljs-subst">-&gt; </span>printf <span class="hljs-string">"We can see you....%s\n"</span> u<span class="hljs-built_in">.</span>Username
<span class="hljs-subst">|</span> Nothing <span class="hljs-subst">-&gt; </span>printf <span class="hljs-string">"No dice!\n"</span></code></pre>

<p>There is nothing more to say, F# is the clear winner here in terms of syntax. In C# my inheritance is starting to become unwieldy and in F# we have solved everything by writing a small record, a Discriminated Union and some code which does a little bit of pattern matching.  </p>



<h2 id="bind">Bind</h2>

<p>The bind function has the following signature:</p>



<p><script type="math/tex; mode=display" id="MathJax-Element-2">
bind :: Ma \rightarrow ( a \rightarrow Mb) \rightarrow Mb
</script></p></div></body>
</html>