---
layout: post
title:  "Monads"
date:   2016-06-04 01:48:00
categories: programming
---


---
THIS DOCUMENT IS INCOMPLETE AND A WORK IN PROGRESS!
---


# Monads

Before writing an article on monads I would like to say that the subject seems a bit less controversial these days. Because of this I would like to do a more *theoretical* version of the monad than most people are doing. This article is more like a recipe for creating monads than a mathematical definition. We are however going to circle back to *monoids* and *Category Theory* at the end of the article.

I am going to provide examples in C#, F# and JavaScript. I am going to ignore Haskell, Lisp and Lispy languages like Clojure because I don't think that adding these languages provides any more relevant information on monads. I do think that learning Haskell is almost the only way to [learn](http://learnyouahaskell.com/) functional programming because the resources out there for learning Haskell are amazing and Haskell is the purest functional language out there. I also believe that Lisp is a superb language and everyone should learn it! What it boils down to is that I really think that learning a programming language a year is a great way to become a master programmer; but, learning monads is quintessential to mastering business applications and that is what this article focuses on.

This tutorial will start with simple objects representing monads, we will add functions to these objects so that we flesh out the functionality. At the end of the article we will walk backwards and look at *monoids* followed by a look at how we can come back to *monads* from them. 

> **Disclaimer:** I'm a JavaScript programmer. This might not mean anything to you, but it means a lot to me. I circumvent all pretense of a type system. I think type systems often serve an academic purpose. Our applications are usually *not so difficult* as to warrant the use of a compiler or a strong type system. Anyone who tries to sell the profession of writing *Line of Business Applications* as being difficult should look at Image Processing, Data Mining, Data Transformations and the necessary performance optimizations needed there. 
> We, as a profession, tend to be lazy in general. I've met a lot of C# programmers who simply do not care about learning other programming languages or *monads*. I've also met Functional Program enthusiasts who do not want to learn the OOP paradigm.  I think that monads are worth your while to learn just as I think OOP is worth every FP's effort.

What do you need to know to read this article? 

 * C# at an intermediate level
 * JavaScript at a beginner level
 * F# at a beginner level

One of the most important concepts you need to know in C# is [generics](https://msdn.microsoft.com/en-us/library/512aeb7t.aspx). You should also be aware of what a [class](https://msdn.microsoft.com/en-us/library/x9afc042.aspx) is and how you can use them. From a JavaScript point of view you'll have to be familiar with prototypes and object literals, I can advice reading [JavaScript the good parts](http://shop.oreilly.com/product/9780596517748.do) a couple of times.

F# is a different story. I do expect the reader to be familiar with F#. Getting to a point where you might be familiar with F# takes a long time, so I think it might be the most difficult thing to ask of the reader. If you are not familiar with F# you can still give this article a try but you are sure to miss subtle nuances.

## Constructors
What is a constructor? A constructor is a function which returns an object. In C# a constructor would look something like:

```csharp
class Person {
    public Person() {
    }
}
```

When we look at this notation I always get a bit "itchy". The fact that there is something which looks like a function but returns nothing scares me. In ES6 this looks a bit different:

```csharp
class Person {
    constructor() {
    }
}
```

For some reason, this JavaScript code,  seems less strange to me; because you write the actual word `constructor` instead of using the name of the class, you get the feeling that this function is special. Apart from this fact, JavaScript does not specify return types and as such there is nothing different about this function. 

## Monads are Objects

Monads are objects. Don't get fooled by all the operations which should be possible on these objects to firmly call them *monads*. In essence, a monad is an object.

Let's create a type which will serve as the base for our *monadic type*:

```
class Monad<T> {
    public readonly T Value;
	public Monad(T t) {
		this.Value = t;
	}
}
```

These are the beginnings of a *Monadic Type*, this constructor is a way to create our fledgeling *Monad*. You may note that this object does nothing more than wrap a value.

## Lift

Using a constructor is not always the same as functionally passing a value into a container. For all situations where we do not want to use the constructor directly but want to *lift* a value to our container type we use a `lift` function. This `lift` function, or operation, is sometimes called the `pure` function.

We will define an operation called `lift` as an operation looks a lot like a constructor. There is an entire philosophical and mathematical reason for calling this function the `lift` function but we are going to ignore that. I think that the terminology is one of the most important parts of learning these difficult concepts and learning terminology should be done in three steps:

 1. Learn the term
 2. Use the term correctly
 3. Learn the etymology of the term

We are going to try and follow this path by blindly learn the new term and then using the new term in examples and exercises. At the end of the article we will try and get to the bottom of the origin of the term and figure out what it means. 

> Our `lift` function is sometimes called a `return` or `pure` function. I am using `lift` here because I find that this term describes its use better.

Let's define `lift`:

$$
lift \; :: \; a \rightarrow M a
$$

In C# this unit function would look a lot like:

```
class Monad<T> {
    public readonly T Value;
	public Monad(T t) {
		this.Value = t;
	}
	
	// lift :: T -> Monad<T>
	public static Monad<T> Lift(T t) {
		return new Monad<T>(t);
	}
}
```

This `Lift` function takes a value in type `T` and returns a value in type `Monad<T>`. If your language has referential transparency we could even say that:

```
if (new Monad<int>(12) == Monad<int>.Lift(12)) {
	Console.WriteLine("They are the same!!");
}
else {
	Console.WriteLine("Oh no, C# only cares about pointers!");
}
```

This result here is my first beef with languages like C#. Comparing things is the most basic of operation in a business application and comparing things by reference is not a great way to it. We should compare the values inside the objects instead of the references, the pointers. 

Let's look at how this would look in F#; first, here's the code for our monad:

```
type Monad<'a> = Value of 'a
```

The unit function would look something like:

```
let lift a = Value a
```

We can use this code by invoking the`unit` function and matching the result, printing something with the Value:

```
let m12 = lift 12
match m12 with
| Value n -> printf "Value is: %d" n
```

The great thing about languages like F# is that we can do:

```
match Value 12 = lift 12 with
| True -> printf "WOOT!"
| False -> printf "No woot ;("
```

Not only is the result `WOOT!`, but I can pattern match on the result, this means that there are no *cases* which I've missed. This is checked and enforced by the compiler.

Let's look at the same example but this time let's use JavaScript. I am not  going to write ES6 classes because I personally don't like them. I really don't like this syntax which everyone seems to be so *comfortable* with. Apart from this, a constructor in JavaScript is not a constructor like we know in for example C# or Java. This will most certainly be a subject of another article.

In JavaScript a *class* is simply a *function* we write it with a capital letter because sir Crockford taught us that that's the way to do it. To be honest, style conventions are quite powerful and should not be ignored. 

```
function Monad(value) {
	this.Value = value;
}

function lift(value) {
	return new Monad(value);
}
```

The `lift` function is quite simple as well. Because we don't have a compiler and an enforced type system we can just *write what we want*. 

Just like with C# `lift(12) === new Monad(12)` will also result in `false`.  This is because JavaScript and C# both check equality by comparing the references, the pointers. These are of course different because they point to different objects. In C# we could override the operator `==` and `!=` to make sure we compare the `Value` property:

```
public class Monad<T> {
    public readonly T Value;
	public Monad(T t) {
		this.Value = t;
	}
	public Monad() {}
	
	public static Monad<T> Unit(T t) {
		return new Monad<T>(t);
	}
	
	public static Func<T, Monad<U>> Map<U>(Func<T,U> f) {
		return (T t) => new Monad<U>(f(t));
	}
	
	public static bool operator == (Monad<T> a, Monad<T> b) {
		return EqualityComparer<T>.Default.Equals(a.Value, b.Value);
	}
	
	public static bool operator != (Monad<T> a, Monad<T> b) {
		return !EqualityComparer<T>.Default.Equals(a.Value, b.Value);
	}
	
	public override bool Equals(System.Object obj)
    {
        // If parameter is null return false.
        if (obj == null) {
            return false;
        }

        // If parameter cannot be cast to Monad<T> return false.
        Monad<T> m = obj as Monad<T>;
        if ((System.Object)m == null) {
            return false;
        }

        // Return true if the fields match:
        return this.Value.Equals(m.Value);
    }

    public bool Equals(Monad<T> m)
    {
        // If parameter is null return false:
        if ((object)m == null) {
            return false;
        }

        // Return true if the fields match:
        return this.Value.Equals(m.Value);
    }

    public override int GetHashCode()
    {
        return this.Value.GetHashCode();
    }
}
```

But as you can imagine this will become unwieldy very fast. Here we only have to check a single value. Imagine having multiple properties....oh the horror! I think it is safe to say that F# is the clear winner when it comes to writing our monadic type and our unit function in a clear and succinct way. 

This is my second beef with languages like C#, everything takes so much code to write. It doesn't matter if you go fully untyped like JavaScript or super typed like F#, you end up with the same functionality but with less code. Less code is not a good thing in and of itself. Readability is very important but I'd like to argue here that what we've written is standard F# and as such should be readable by everyone.

> The FP community tends to write applications using a lot of `x` and `y` for their parameters. I do the same some times. It is important to realize that just as with languages like C#, naming your parameters and functions is every important! Let's leave the `x` and `y` alone and come up with better names.

Up to this point we've only seen ways to create an object and pass some data into the constructor.  This is neither new nor exiting as far as programming goes. What matters is what this can do. The next chapter will give a small example of using this technique to create a robust system where we can work with data in very solid way.

## Maybe?

We've all had to deal with null reference exceptions in the passed. Maybe we've even had applications deployed to production which crashed on a null reference exception. This is really painful because it is a clear programming error. If we had programmed more defensively and checked ***every*** object for null this error would not have occurred. 

There must be a better way than to litter your code with null checks? There is, if you step into the land of monads you will encounter a pearl, the *maybe monad*. Look at the next piece of code. I've done a few things, the first thing is that I've added an empty constructor to the `Monad` class. The second thing is that I've created three new classes: `Maybe`, `Nothing` and `Just`.

The idea behind these classes is that we never return a data object from functions anymore but we always return `Maybe<T>`. If we do this we can never encounter a null reference exception in our code again!  

```
public class Maybe<T> : Monad<T> {
	public Maybe(T t) : base(t) {}
	public Maybe() {}
}
public class Nothing<T> : Maybe<T> {
	new private T Value;
}
public class Just<T> : Maybe<T> {
	public Just(T t) : base(t) {}
}
```

How would we use this code? Well imagine querying a database for a user by `Id`. You don't know if the user exists or not. (*side note*: let's ignore errors for now. The next couple of examples will focus on errors.) When you get your result you want to know for certain if what you got was a user or not. Somehow you want the compiler to catch references to nothing. Here, the `Maybe<User>` class can help us out. Because we've sub-classed `Maybe` we can [upcast](https://en.wikipedia.org/wiki/Polymorphism_(computer_science)) or type-check our result and safely continue with the data once we've gotten the data.

```
public class User {
	public readonly string Username;
	public User(string username) {
		this.Username = username;
	}

	// Simulate querying the user from the database.
	// return Just<User> on odd ids
	// return Nothing<User> on even ids
	public static Maybe<User> GetUserById(int id) {
		if (id % 2 == 0) {
			return (Maybe<User>)new Just<User>(new User("Carlos"));
		}
		else {
			return (Maybe<User>)new Nothing<User>();
		}
	}
}
```

The GetUserById function has the following signature:

$$
GetUserById \; :: \; int \rightarrow Maybe \langle User \rangle
$$

So it's of type:

$$
f :: a \rightarrow Mb
$$

As you can see, this function is not really the same as the lift function but it does lift a value to a elevated state.  I really think that this is the core of all of our problems understanding *monads*, *Functors* and other functional jargon. We are so afraid of what is written that we fail to read. We've done nothing difficult here, we've defined a simple function which instead of returning a `User` or `null` we're returning a `Maybe<User>`. 

But what does it mean? How can we use this code? 
```javascript
var user = User.GetUserById(2);
if (user is Nothing<User>) {
	Console.WriteLine("We got nothing!");
}
else if (user is Just<User>) {
	Console.WriteLine("We got you...." + ((Just<User>)user).Value.Username);
}
```

You might ask why this is better than simply checking for `null`. The difference is that in the null check we have lost a bit of our type. In the example using the Maybe  class we *have* to type check in order to get to the Value. 

In this previous example you have seen polymorphism at it's best. This is clear cut example of polymorphism and how it can help you build better software but how would we write this in F#? 

```fsharp
type User = { Username: string }

type Maybe<'a> =
	| Just of 'a
	| Nothing

let getUserById id =
    match id % 2 with
    | 0 -> Just { Username = "Carlos" }
    | _ -> Nothing
    
let user = getUserById 2

match user with
| Just u -> printf "We can see you....%s\n" u.Username
| Nothing -> printf "No dice!\n"
```

There is nothing more to say, F# is the clear winner here in terms of syntax. In C# my inheritance is starting to become unwieldy and in F# we have solved everything by writing a small record, a Discriminated Union and some code which does a little bit of pattern matching.  We didn't even have to implement all of the equality fluff.

## Map

I hope that the previous examples, the Maybe example, convinced you that there is a valid use case for a type like our `Monad<T>`.  But does this mean that we need to rewrite all our code and maybe even all of the code in 3e party libraries in order to use this `Monad<T>` everywhere? No, that would be really inconvenient and it would even be a bit silly. What we need to do is we need to create some function which *lifts* our parameters from being normal to being something of type `Monad<T>`. Luckily we've arrived at a chapter which has the name of the function we will need. The `map` function.

$$
map \; :: \; (a \rightarrow b) \rightarrow (Ma \rightarrow Mb)
$$

In C# this map function could look something like:

```
public static Func<Maybe<T>, Maybe<U>> map<T, U>(Func<T, U> f) {
	return (Maybe<T> Mt) => {
		// if we get nothing in, we return nothing...
		if (Mt is Nothing<T>) return new Nothing<U>();
		
		// else we much about with some values and casts and return our value
		U result = f((Mt as Just<T>).Value);
		if (result == null) return new Nothing<U>();
		else return new Just<U>(result);
	};
}
```

In F# this would look like:

```
let map f =
	fun Ma ->
		match Ma with
		| Nothing -> Nothing
		| Just a ->
			Just (f a)
```

The main difference is that in F# we can never have a function return `null`, so the need for the `Maybe`class is less. The way in F# you return *nothing* is by using the `Option` type which is exactly the same as the `Maybe` type we just created.

## Something

$$
map \; :: \; (a \rightarrow Mb) \rightarrow (Ma \rightarrow Mb)
$$


## Bind

The bind function has the following signature:

$$
bind :: Ma \rightarrow ( a \rightarrow Mb) \rightarrow Mb
$$




## SAMPLE
```
using System;
using System.Linq;
		
// Our little monad class.
abstract class Monad<T> {
	public readonly T Value;
	public Monad() {}
	public Monad(T t) {
		this.Value = t;
	}
}

// Our abstract Maybe class, used as the root of
// the Just and Nothing branches.
abstract class Maybe<T> : Monad<T> {
	public Maybe() : base() {}
	public Maybe(T t): base(t) {}
}
// Indicates we have a value.
sealed class Just<T> : Maybe<T> {
	public Just(T t) : base(t) {}	
}
// indicates we have nothing.
sealed class Nothing<T> : Maybe<T> {
	public Nothing() : base() {}
}


public class Program
{
	
	private static Func<int, Maybe<int>> getNumber = (int x) => {
		if (x % 2 == 0) {
			return (Maybe<int>)new Just<int>(x);
		}
		else {
			return (Maybe<int>)new Nothing<int>();
		}
	};
	
	private static Maybe<T> print<T>(Maybe<T> m) {
		if (m is Just<T>) {
			Console.WriteLine("Your number is: " + (m as Just<T>).Value.ToString());
		} else {
			Console.WriteLine("This is not a number");
		}
		return m;
	}
	
	private static Func<int, Maybe<int>> compose = (int x) => {
		return print(getNumber(x));
	};
	
	
	public static void Main()
	{
		// simple example where we query the numbers
		// and use a linq query to process the numbers and 
		// get the result...
		int[] numbers = { 1,2,3,4,5,6,7,8,9,10 };
		var nm = from n in numbers 
				 select compose(n);
		nm.ToList();
	}
}
```