<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Monads</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</head>
<body><div class="container"><hr>



<h2 id="this-document-is-incomplete-and-a-work-in-progress">THIS DOCUMENT IS INCOMPLETE AND A WORK IN PROGRESS!</h2>



<h1 id="monads">Monads</h1>

<p>Before writing an article on monads I would like to say that the subject seems a bit less controversial these days. Because of this I would like to do a more <em>theoretical</em> version of the monad than most people are doing. This article is more like a recipe for creating monads than a mathematical definition. We are however going to circle back to <em>monoids</em> and <em>Category Theory</em> at the end of the article.</p>

<p>I am going to provide examples in C#, F# and JavaScript. I am going to ignore Haskell, Lisp and Lispy languages like Clojure because I don’t think that adding these languages provides any more relevant information on monads. I do think that learning Haskell is almost the only way to <a href="http://learnyouahaskell.com/">learn</a> functional programming because the resources out there for learning Haskell are amazing and Haskell is the purest functional language out there. I also believe that Lisp is a superb language and everyone should learn it! What it boils down to is that I really think that learning a programming language a year is a great way to become a master programmer; but, learning monads is quintessential to mastering business applications and that is what this article focuses on.</p>

<p>This tutorial will start with simple objects representing monads, we will add functions to these objects so that we flesh out the functionality. At the end of the article we will walk backwards and look at <em>monoids</em> followed by a look at how we can come back to <em>monads</em> from them. </p>

<blockquote>
  <p><strong>Disclaimer:</strong> I’m a JavaScript programmer. This might not mean anything to you, but it means a lot to me. I circumvent all pretense of a type system. I think type systems often serve an academic purpose. Our applications are usually <em>not so difficult</em> as to warrant the use of a compiler or a strong type system. Anyone who tries to sell the profession of writing <em>Line of Business Applications</em> as being difficult should look at Image Processing, Data Mining, Data Transformations and the necessary performance optimizations needed there.  <br>
  We, as a profession, tend to be lazy in general. I’ve met a lot of C# programmers who simply do not care about learning other programming languages or <em>monads</em>. I’ve also met Functional Program enthusiasts who do not want to learn the OOP paradigm.  I think that monads are worth your while to learn just as I think OOP is worth every FP’s effort.</p>
</blockquote>

<p>What do you need to know to read this article? </p>

<ul>
<li>C# at an intermediate level</li>
<li>JavaScript at a beginner level</li>
<li>F# at a beginner level</li>
</ul>

<p>One of the most important concepts you need to know in C# is <a href="https://msdn.microsoft.com/en-us/library/512aeb7t.aspx">generics</a>. You should also be aware of what a <a href="https://msdn.microsoft.com/en-us/library/x9afc042.aspx">class</a> is and how you can use them. From a JavaScript point of view you’ll have to be familiar with prototypes and object literals, I can advice reading <a href="http://shop.oreilly.com/product/9780596517748.do">JavaScript the good parts</a> a couple of times.</p>

<p>F# is a different story. I do expect the reader to be familiar with F#. Getting to a point where you might be familiar with F# takes a long time, so I think it might be the most difficult thing to ask of the reader. If you are not familiar with F# you can still give this article a try but you are sure to miss subtle nuances.</p>



<h2 id="constructors">Constructors</h2>

<p>What is a constructor? A constructor is a function which returns an object. In C# a constructor would look something like:</p>



<pre class="prettyprint"><code class="language-csharp hljs cs">class Person {
    <span class="hljs-keyword">public</span> <span class="hljs-title">Person</span>() {
    }
}</code></pre>

<p>When we look at this notation I always get a bit “itchy”. The fact that there is something which looks like a function but returns nothing scares me. In ES6 this looks a bit different:</p>

<pre class="prettyprint"><code class="language-csharp hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> {</span>
    constructor() {
    }
}</code></pre>

<p>For some reason, this JavaScript code,  seems less strange to me; because you write the actual word <code>constructor</code> instead of using the name of the class, you get the feeling that this function is special. Apart from this fact, JavaScript does not specify return types and as such there is nothing different about this function. </p>

<h2 id="monads-are-objects">Monads are Objects</h2>

<p>Monads are objects. Don’t get fooled by all the operations which should be possible on these objects to firmly call them <em>monads</em>. In essence, a monad is an object.</p>

<p>Let’s create a type which will serve as the base for our <em>monadic type</em>:</p>



<pre class="prettyprint"><code class=" hljs cs">class Monad&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> T Value;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Monad</span>(T t) {
        <span class="hljs-keyword">this</span>.Value = t;
    }
}</code></pre>

<p>These are the beginnings of a <em>Monadic Type</em>, this constructor is a way to create our fledgeling <em>Monad</em>. You may note that this object does nothing more than wrap a value.</p>



<h2 id="lift">Lift</h2>

<p>Using a constructor is not always the same as functionally passing a value into a container. For all situations where we do not want to use the constructor directly but want to <em>lift</em> a value to our container type we use a <code>lift</code> function. This <code>lift</code> function, or operation, is sometimes called the <code>pure</code> function.</p>

<p>We will define an operation called <code>lift</code> as an operation looks a lot like a constructor. There is an entire philosophical and mathematical reason for calling this function the <code>lift</code> function but we are going to ignore that. I think that the terminology is one of the most important parts of learning these difficult concepts and learning terminology should be done in three steps:</p>

<ol>
<li>Learn the term</li>
<li>Use the term correctly</li>
<li>Learn the etymology of the term</li>
</ol>

<p>We are going to try and follow this path by blindly learn the new term and then using the new term in examples and exercises. At the end of the article we will try and get to the bottom of the origin of the term and figure out what it means. </p>

<blockquote>
  <p>Our <code>lift</code> function is sometimes called a <code>return</code> or <code>pure</code> function. I am using <code>lift</code> here because I find that this term describes its use better.</p>
</blockquote>

<p>Let’s define <code>lift</code>:</p>



<p><script type="math/tex; mode=display" id="MathJax-Element-1">
lift \; :: \; a \rightarrow M a
</script></p>

<p>In C# this unit function would look a lot like:</p>



<pre class="prettyprint"><code class=" hljs cs">class Monad&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> T Value;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Monad</span>(T t) {
        <span class="hljs-keyword">this</span>.Value = t;
    }

    <span class="hljs-comment">// lift :: T -&gt; Monad&lt;T&gt;</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Monad&lt;T&gt; <span class="hljs-title">Lift</span>(T t) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Monad&lt;T&gt;(t);
    }
}</code></pre>

<p>This <code>Lift</code> function takes a value in type <code>T</code> and returns a value in type <code>Monad&lt;T&gt;</code>. If your language has referential transparency we could even say that:</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> Monad&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">12</span>) == Monad&lt;<span class="hljs-keyword">int</span>&gt;.Lift(<span class="hljs-number">12</span>)) {
    Console.WriteLine(<span class="hljs-string">"They are the same!!"</span>);
}
<span class="hljs-keyword">else</span> {
    Console.WriteLine(<span class="hljs-string">"Oh no, C# only cares about pointers!"</span>);
}</code></pre>

<p>This result here is my first beef with languages like C#. Comparing things is the most basic of operation in a business application and comparing things by reference is not a great way to it. We should compare the values inside the objects instead of the references, the pointers. </p>

<p>Let’s look at how this would look in F#; first, here’s the code for our monad:</p>



<pre class="prettyprint"><code class=" hljs fsharp"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Monad</span>&lt;'<span class="hljs-title">a</span>&gt; =</span> Value <span class="hljs-keyword">of</span> <span class="hljs-attribute">'a</span></code></pre>

<p>The unit function would look something like:</p>



<pre class="prettyprint"><code class=" hljs livecodeserver">let lift <span class="hljs-operator">a</span> = Value <span class="hljs-operator">a</span></code></pre>

<p>We can use this code by invoking the<code>unit</code> function and matching the result, printing something with the Value:</p>



<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-keyword">let</span> m12 <span class="hljs-subst">=</span> lift <span class="hljs-number">12</span>
<span class="hljs-keyword">match</span> m12 <span class="hljs-keyword">with</span>
<span class="hljs-subst">|</span> Value n <span class="hljs-subst">-&gt; </span>printf <span class="hljs-string">"Value is: %d"</span> n</code></pre>

<p>The great thing about languages like F# is that we can do:</p>



<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-keyword">match</span> Value <span class="hljs-number">12</span> <span class="hljs-subst">=</span> lift <span class="hljs-number">12</span> <span class="hljs-keyword">with</span>
<span class="hljs-subst">|</span> <span class="hljs-literal">True</span> <span class="hljs-subst">-&gt; </span>printf <span class="hljs-string">"WOOT!"</span>
<span class="hljs-subst">|</span> <span class="hljs-literal">False</span> <span class="hljs-subst">-&gt; </span>printf <span class="hljs-string">"No woot ;("</span></code></pre>

<p>Not only is the result <code>WOOT!</code>, but I can pattern match on the result, this means that there are no <em>cases</em> which I’ve missed. This is checked and enforced by the compiler.</p>

<p>Let’s look at the same example but this time let’s use JavaScript. I am not  going to write ES6 classes because I personally don’t like them. I really don’t like this syntax which everyone seems to be so <em>comfortable</em> with. Apart from this, a constructor in JavaScript is not a constructor like we know in for example C# or Java. This will most certainly be a subject of another article.</p>

<p>In JavaScript a <em>class</em> is simply a <em>function</em> we write it with a capital letter because sir Crockford taught us that that’s the way to do it. To be honest, style conventions are quite powerful and should not be ignored. </p>



<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Monad</span><span class="hljs-params">(value)</span> {</span>
    <span class="hljs-keyword">this</span>.Value = value;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lift</span><span class="hljs-params">(value)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Monad(value);
}</code></pre>

<p>The <code>lift</code> function is quite simple as well. Because we don’t have a compiler and an enforced type system we can just <em>write what we want</em>. </p>

<p>Just like with C# <code>lift(12) === new Monad(12)</code> will also result in <code>false</code>.  This is because JavaScript and C# both check equality by comparing the references, the pointers. These are of course different because they point to different objects. In C# we could override the operator <code>==</code> and <code>!=</code> to make sure we compare the <code>Value</code> property:</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Monad&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> T Value;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Monad</span>(T t) {
        <span class="hljs-keyword">this</span>.Value = t;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-title">Monad</span>() {}

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Monad&lt;T&gt; <span class="hljs-title">Unit</span>(T t) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Monad&lt;T&gt;(t);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Func&lt;T, Monad&lt;U&gt;&gt; Map&lt;U&gt;(Func&lt;T,U&gt; f) {
        <span class="hljs-keyword">return</span> (T t) =&gt; <span class="hljs-keyword">new</span> Monad&lt;U&gt;(f(t));
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> == (Monad&lt;T&gt; a, Monad&lt;T&gt; b) {
        <span class="hljs-keyword">return</span> EqualityComparer&lt;T&gt;.Default.Equals(a.Value, b.Value);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> != (Monad&lt;T&gt; a, Monad&lt;T&gt; b) {
        <span class="hljs-keyword">return</span> !EqualityComparer&lt;T&gt;.Default.Equals(a.Value, b.Value);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Equals</span>(System.Object obj)
    {
        <span class="hljs-comment">// If parameter is null return false.</span>
        <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }

        <span class="hljs-comment">// If parameter cannot be cast to Monad&lt;T&gt; return false.</span>
        Monad&lt;T&gt; m = obj <span class="hljs-keyword">as</span> Monad&lt;T&gt;;
        <span class="hljs-keyword">if</span> ((System.Object)m == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }

        <span class="hljs-comment">// Return true if the fields match:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.Value.Equals(m.Value);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Equals</span>(Monad&lt;T&gt; m)
    {
        <span class="hljs-comment">// If parameter is null return false:</span>
        <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">object</span>)m == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }

        <span class="hljs-comment">// Return true if the fields match:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.Value.Equals(m.Value);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetHashCode</span>()
    {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.Value.GetHashCode();
    }
}</code></pre>

<p>But as you can imagine this will become unwieldy very fast. Here we only have to check a single value. Imagine having multiple properties….oh the horror! I think it is safe to say that F# is the clear winner when it comes to writing our monadic type and our unit function in a clear and succinct way. </p>

<p>This is my second beef with languages like C#, everything takes so much code to write. It doesn’t matter if you go fully untyped like JavaScript or super typed like F#, you end up with the same functionality but with less code. Less code is not a good thing in and of itself. Readability is very important but I’d like to argue here that what we’ve written is standard F# and as such should be readable by everyone.</p>

<blockquote>
  <p>The FP community tends to write applications using a lot of <code>x</code> and <code>y</code> for their parameters. I do the same some times. It is important to realize that just as with languages like C#, naming your parameters and functions is every important! Let’s leave the <code>x</code> and <code>y</code> alone and come up with better names.</p>
</blockquote>

<p>Up to this point we’ve only seen ways to create an object and pass some data into the constructor.  This is neither new nor exiting as far as programming goes. What matters is what this can do. The next chapter will give a small example of using this technique to create a robust system where we can work with data in very solid way.</p>



<h2 id="maybe">Maybe?</h2>

<p>We’ve all had to deal with null reference exceptions in the passed. Maybe we’ve even had applications deployed to production which crashed on a null reference exception. This is really painful because it is a clear programming error. If we had programmed more defensively and checked <strong><em>every</em></strong> object for null this error would not have occurred. </p>

<p>There must be a better way than to litter your code with null checks? There is, if you step into the land of monads you will encounter a pearl, the <em>maybe monad</em>. Look at the next piece of code. I’ve done a few things, the first thing is that I’ve added an empty constructor to the <code>Monad</code> class. The second thing is that I’ve created three new classes: <code>Maybe</code>, <code>Nothing</code> and <code>Just</code>.</p>

<p>The idea behind these classes is that we never return a data object from functions anymore but we always return <code>Maybe&lt;T&gt;</code>. If we do this we can never encounter a null reference exception in our code again!  </p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Maybe&lt;T&gt; : Monad&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-title">Maybe</span>(T t) : <span class="hljs-title">base</span>(t) {}
    <span class="hljs-keyword">public</span> <span class="hljs-title">Maybe</span>() {}
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Nothing&lt;T&gt; : Maybe&lt;T&gt; {
    <span class="hljs-keyword">new</span> <span class="hljs-keyword">private</span> T Value;
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Just&lt;T&gt; : Maybe&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-title">Just</span>(T t) : <span class="hljs-title">base</span>(t) {}
}</code></pre>

<p>How would we use this code? Well imagine querying a database for a user by <code>Id</code>. You don’t know if the user exists or not. (<em>side note</em>: let’s ignore errors for now. The next couple of examples will focus on errors.) When you get your result you want to know for certain if what you got was a user or not. Somehow you want the compiler to catch references to nothing. Here, the <code>Maybe&lt;User&gt;</code> class can help us out. Because we’ve sub-classed <code>Maybe</code> we can <a href="https://en.wikipedia.org/wiki/Polymorphism_%28computer_science%29">upcast</a> or type-check our result and safely continue with the data once we’ve gotten the data.</p>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> User {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">string</span> Username;
    <span class="hljs-keyword">public</span> <span class="hljs-title">User</span>(<span class="hljs-keyword">string</span> username) {
        <span class="hljs-keyword">this</span>.Username = username;
    }

    <span class="hljs-comment">// Simulate querying the user from the database.</span>
    <span class="hljs-comment">// return Just&lt;User&gt; on odd ids</span>
    <span class="hljs-comment">// return Nothing&lt;User&gt; on even ids</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Maybe&lt;User&gt; <span class="hljs-title">GetUserById</span>(<span class="hljs-keyword">int</span> id) {
        <span class="hljs-keyword">if</span> (id % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> (Maybe&lt;User&gt;)<span class="hljs-keyword">new</span> Just&lt;User&gt;(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"Carlos"</span>));
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> (Maybe&lt;User&gt;)<span class="hljs-keyword">new</span> Nothing&lt;User&gt;();
        }
    }
}</code></pre>

<p>The GetUserById function has the following signature:</p>



<p><script type="math/tex; mode=display" id="MathJax-Element-2">
GetUserById \; :: \; int \rightarrow Maybe \langle User \rangle
</script></p>

<p>So it’s of type:</p>



<p><script type="math/tex; mode=display" id="MathJax-Element-17">
f :: a \rightarrow Mb
</script></p>

<p>As you can see, this function is not really the same as the lift function but it does lift a value to a elevated state.  I really think that this is the core of all of our problems understanding <em>monads</em>, <em>Functors</em> and other functional jargon. We are so afraid of what is written that we fail to read. We’ve done nothing difficult here, we’ve defined a simple function which instead of returning a <code>User</code> or <code>null</code> we’re returning a <code>Maybe&lt;User&gt;</code>. </p>

<p>But what does it mean? How can we use this code? </p>



<pre class="prettyprint"><code class="language-javascript hljs "><span class="hljs-keyword">var</span> user = User.GetUserById(<span class="hljs-number">2</span>);
<span class="hljs-keyword">if</span> (user is Nothing&lt;User&gt;) {
    Console.WriteLine(<span class="hljs-string">"We got nothing!"</span>);
}
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (user is Just&lt;User&gt;) {
    Console.WriteLine(<span class="hljs-string">"We got you...."</span> + ((Just&lt;User&gt;)user).Value.Username);
}</code></pre>

<p>You might ask why this is better than simply checking for <code>null</code>. The difference is that in the null check we have lost a bit of our type. In the example using the Maybe  class we <em>have</em> to type check in order to get to the Value. </p>

<p>In this previous example you have seen polymorphism at it’s best. This is clear cut example of polymorphism and how it can help you build better software but how would we write this in F#? </p>



<pre class="prettyprint"><code class="language-fsharp hljs "><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">User</span> =</span> { Username: string }

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Maybe</span>&lt;'<span class="hljs-title">a</span>&gt; =</span>
    | Just <span class="hljs-keyword">of</span> <span class="hljs-attribute">'a</span>
    | Nothing

<span class="hljs-keyword">let</span> getUserById id =
    <span class="hljs-keyword">match</span> id % <span class="hljs-number">2</span> <span class="hljs-keyword">with</span>
    | <span class="hljs-number">0</span> -&gt; Just { Username = <span class="hljs-string">"Carlos"</span> }
    | _ -&gt; Nothing

<span class="hljs-keyword">let</span> user = getUserById <span class="hljs-number">2</span>

<span class="hljs-keyword">match</span> user <span class="hljs-keyword">with</span>
| Just u -&gt; printf <span class="hljs-string">"We can see you....%s\n"</span> u.Username
| Nothing -&gt; printf <span class="hljs-string">"No dice!\n"</span></code></pre>

<p>There is nothing more to say, F# is the clear winner here in terms of syntax. In C# my inheritance is starting to become unwieldy and in F# we have solved everything by writing a small record, a Discriminated Union and some code which does a little bit of pattern matching.  We didn’t even have to implement all of the equality fluff.</p>

<h2 id="map">Map</h2>

<p>I hope that the previous examples, the Maybe example, convinced you that there is a valid use case for a type like our <code>Monad&lt;T&gt;</code>.  But does this mean that we need to rewrite all our code and maybe even all of the code in 3e party libraries in order to use this <code>Monad&lt;T&gt;</code> everywhere? No, that would be really inconvenient and it would even be a bit silly. What we need to do is we need to create some function which <em>lifts</em> our parameters from being normal to being something of type <code>Monad&lt;T&gt;</code>. Luckily we’ve arrived at a chapter which has the name of the function we will need. The <code>map</code> function.</p>



<p><script type="math/tex; mode=display" id="MathJax-Element-18">
map \; :: \; (a \rightarrow b) \rightarrow (Ma \rightarrow Mb)
</script></p>

<p>In C# this map function could look something like:</p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Func&lt;Maybe&lt;T&gt;, Maybe&lt;U&gt;&gt; <span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;T, U&gt;</span>(Func&lt;T, U&gt; f) {
    <span class="hljs-keyword">return</span> (Maybe&lt;T&gt; Mt) =&gt; {
        <span class="hljs-comment">// if we get nothing in, we return nothing...</span>
        <span class="hljs-keyword">if</span> (Mt is Nothing&lt;T&gt;) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Nothing&lt;U&gt;();

        <span class="hljs-comment">// else we much about with some values and casts and return our value</span>
        U result = f((Mt as Just&lt;T&gt;).Value);
        <span class="hljs-keyword">if</span> (result == null) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Nothing&lt;U&gt;();
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Just&lt;U&gt;(result);
    };
}</code></pre>

<p>In F# this would look like:</p>



<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-keyword">let</span> <span class="hljs-built_in">map</span> f <span class="hljs-subst">=</span>
    fun Ma <span class="hljs-subst">-&gt;
        </span><span class="hljs-keyword">match</span> Ma <span class="hljs-keyword">with</span>
        <span class="hljs-subst">|</span> Nothing <span class="hljs-subst">-&gt; </span>Nothing
        <span class="hljs-subst">|</span> Just a <span class="hljs-subst">-&gt;
            </span>Just (f a)</code></pre>

<p>The main difference is that in F# we can never have a function return <code>null</code>, so the need for the <code>Maybe</code>class is less. The way in F# you return <em>nothing</em> is by using the <code>Option</code> type which is exactly the same as the <code>Maybe</code> type we just created.</p>



<h2 id="something">Something</h2>

<p><script type="math/tex; mode=display" id="MathJax-Element-19">
map \; :: \; (a \rightarrow Mb) \rightarrow (Ma \rightarrow Mb)
</script></p>



<h2 id="bind">Bind</h2>

<p>The bind function has the following signature:</p>



<p><script type="math/tex; mode=display" id="MathJax-Element-20">
bind :: Ma \rightarrow ( a \rightarrow Mb) \rightarrow Mb
</script></p>



<h2 id="sample">SAMPLE</h2>



<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Linq;

<span class="hljs-comment">// Our little monad class.</span>
<span class="hljs-keyword">abstract</span> class Monad&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">readonly</span> T Value;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Monad</span>() {}
    <span class="hljs-keyword">public</span> <span class="hljs-title">Monad</span>(T t) {
        <span class="hljs-keyword">this</span>.Value = t;
    }
}

<span class="hljs-comment">// Our abstract Maybe class, used as the root of</span>
<span class="hljs-comment">// the Just and Nothing branches.</span>
<span class="hljs-keyword">abstract</span> class Maybe&lt;T&gt; : Monad&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-title">Maybe</span>() : <span class="hljs-title">base</span>() {}
    <span class="hljs-keyword">public</span> <span class="hljs-title">Maybe</span>(T t): <span class="hljs-title">base</span>(t) {}
}
<span class="hljs-comment">// Indicates we have a value.</span>
<span class="hljs-keyword">sealed</span> class Just&lt;T&gt; : Maybe&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-title">Just</span>(T t) : <span class="hljs-title">base</span>(t) {}   
}
<span class="hljs-comment">// indicates we have nothing.</span>
<span class="hljs-keyword">sealed</span> class Nothing&lt;T&gt; : Maybe&lt;T&gt; {
    <span class="hljs-keyword">public</span> <span class="hljs-title">Nothing</span>() : <span class="hljs-title">base</span>() {}
}


<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Program
{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Func&lt;<span class="hljs-keyword">int</span>, Maybe&lt;<span class="hljs-keyword">int</span>&gt;&gt; getNumber = (<span class="hljs-keyword">int</span> x) =&gt; {
        <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> (Maybe&lt;<span class="hljs-keyword">int</span>&gt;)<span class="hljs-keyword">new</span> Just&lt;<span class="hljs-keyword">int</span>&gt;(x);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> (Maybe&lt;<span class="hljs-keyword">int</span>&gt;)<span class="hljs-keyword">new</span> Nothing&lt;<span class="hljs-keyword">int</span>&gt;();
        }
    };

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Maybe&lt;T&gt; print&lt;T&gt;(Maybe&lt;T&gt; m) {
        <span class="hljs-keyword">if</span> (m <span class="hljs-keyword">is</span> Just&lt;T&gt;) {
            Console.WriteLine(<span class="hljs-string">"Your number is: "</span> + (m <span class="hljs-keyword">as</span> Just&lt;T&gt;).Value.ToString());
        } <span class="hljs-keyword">else</span> {
            Console.WriteLine(<span class="hljs-string">"This is not a number"</span>);
        }
        <span class="hljs-keyword">return</span> m;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Func&lt;<span class="hljs-keyword">int</span>, Maybe&lt;<span class="hljs-keyword">int</span>&gt;&gt; compose = (<span class="hljs-keyword">int</span> x) =&gt; {
        <span class="hljs-keyword">return</span> print(getNumber(x));
    };


    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()
    {
        <span class="hljs-comment">// simple example where we query the numbers</span>
        <span class="hljs-comment">// and use a linq query to process the numbers and </span>
        <span class="hljs-comment">// get the result...</span>
        <span class="hljs-keyword">int</span>[] numbers = { <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span> };
        <span class="hljs-keyword">var</span> nm = <span class="hljs-keyword">from</span> n <span class="hljs-keyword">in</span> numbers 
                 <span class="hljs-keyword">select</span> compose(n);
        nm.ToList();
    }
}</code></pre></div></body>
</html>